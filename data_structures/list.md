---
layout: default
parent: データ構造
summary: 
---

# リスト list

## 使い方

```python
l = []  # 空の配列
l = [0]*n  # 0 で初期化した要素数 n の配列
l = [[0]*n for _ in range(m)]  # 0 で初期化した要素数 n*m の配列
```

## 計算量

|操作|コード|最悪計算量|備考|
|---|:-:|:-:|---|
|$k$ 番目の要素にアクセス| `l[k]` |$O(1)$|
|配列内に要素 `a` があるか判定|`a in l`|$O(n)$|すべての要素を確認するため|
|要素数を取得|`len(l)`|$O(1)$|
|**末尾に**要素 `a` を挿入|`l.append(a)`|$O(1)$|
|$k$ 番目に要素 `a` を挿入|`l.insert(k, a)`|$O(n)$|後ろの要素をすべて 1 つずつずらすため|
|**末尾**の要素を削除|`l.pop()`|$O(1)$|
|$k$ 番目の要素を削除|`l.pop(k)`|$O(n)$|後ろの要素をすべて 1 つずつずらすため|

- 厳密にはリストと配列は違う (配列 `array` もある) が、ほとんど配列だと思って問題ない


## 両端キュー deque (double-ended queue)

```python
from collections import deque

d = deque()  # 空の deque オブジェクト
l = [3, 1, 4, 1, 5]  # 普通のリスト
d = deque(l)  # リストを deque オブジェクトに変換できる
```

|操作|コード|最悪計算量|備考|
|---|:-:|:-:|---|
|**末尾に**要素 `a` を挿入|`l.append(a)`|$O(1)$|
|**先頭に**要素 `a` を挿入|`l.appendleft(a)`|$O(1)$|
|$k$ 番目に要素 `a` を挿入|`l.insert(k, a)`|$O(n)$|真ん中付近は遅い|
|**末尾**の要素を削除|`l.pop()`|$O(1)$|
|**先頭**の要素を削除|`l.popleft()`|$O(1)$|
|$k$ 番目の要素を削除|`l.pop(k)`|$O(n)$|真ん中付近は遅い|

## 優先度付きキュー heapq

```python
import heapq

l = [3, 1, 4, 1, 5]
heapq.heapify(l)  # リストからヒープを作成
```

|操作|コード|最悪計算量|備考|
|---|:-:|:-:|---|
|リスト `l` からヒープを構築|`heapq.heapify(l)`|$O(n)$|
|要素 `a` を追加|`heapq.heappush(l, a)`|$O(\log n)$|
|最小値を取得|`heapq.heappop(l)`|$O(\log n)$|
|最大値を取得|-|$O(\log n)$|すべての要素に -1 を掛けてもうひとつヒープを作成しておく|

- リスト `l` の最小値を得るだけなら `min(l)` でよい
- ソートされていないリストから小さい順に $k$ 個の値を取り出すときの計算量は
    - ソート: $O(n \log n)$
    - 優先度付きキュー: $O(n + k \log n)$
- 値を取り出す途中で挿入も発生する場合は `heapq` を使うべき